# **Professional Self-Assessment**
After transferring to SNHU, I started the computer science program and gained momentum by using real devices to practice real skills which has influenced the way I view my strengths and professional goals. I first concentrated on the basics before focusing on mobile development after creating an Android app and then rewriting it in Kotlin. I learned how to clearly explain results and relate decisions to what employers value by keeping a record of my plans and progress. By thinking back on my development, I was able to transition from a broad interest in software to a specific path in Android development with specific next steps, such as certification and further education.

I was able to establish a consistent approach to software engineering through the coursework throughout the program. I gained the ability to modernize code without affecting user behavior and to separate concerns between the platform services, persistence layer, and user interface. My habits regarding null safety, succinct data representations, and readable logic were reinforced when I switched to Kotlin. I also worked on writing design notes that clearly explain tradeoffs and provide justifications for changes. These practices facilitate teamwork, lower maintenance costs, and demonstrate my ability to maintain a codebase's stability as it evolves.

By selecting data structures that align with actual product constraints, I improved my algorithmic and data structure judgment. By constructing a scheduler based on a priority queue, I developed the ability to reason about correctness initially followed by considerations of scale. Also, I learned how to prepare the next scheduled item in advance, how to efficiently rebuild from storage, and how to manage edge cases such as event edits occurring close to a trigger time. This experience solidified the concept that decisions for algorithms should help create more predictable and understandable behavior as the application grows.

My work with databases has improved my understanding of how models enable features. Also, this database work allowed me to gain the skills required to create migrations that protect existing data, index fields that enable common queries, and store times as precise epoch values instead of as strings. When schema validation required the recreation of a table, I made the necessary modifications to ensure the structure stuck to the persistence library's specifications and I confirmed the outcomes through simple tests. With those competencies, I'm now able to securely develop a schema and preserve the application's responsiveness as the volume of data grows.

Instead of being something I add at the end, security has become a part of my routine. I was able to minimize exposure by using permission checks, replacing plain text credentials with salted hashes, keeping sensitive data out of logs, and keeping broadcast components inside the app. By verifying that behavior remained constant while the surface area for errors decreased, I was able to link these choices to user impact. I plan to approach a team with a mindset that treats security and meticulous logging as a standard engineering practice.

Collaboration and communication improved as I engaged in quicker feedback cycles. I equipped myself for code reviews by utilizing targeted checklists, brief sessions, and author notes to provide reviewers with context. I structured recorded walkthroughs based on explicit criteria, enabling a teammate to understand the rationale and observe the impact of modifications. Also, I improved my ability to communicate effectively with stakeholders by summarizing objectives, explaining limitations, and demonstrating how the work aligns with user and business requirements. I was able to present results in an easily evaluable manner by writing with hiring managers in mind.

My approach to assessing opportunities has been influenced by researching trends. I focused on the ways that learning loops link data, assessment, and human feedback, as well as the ongoing blending of mobile experiences with spatial interfaces. My interest in scheduling, notifications, and multimedia on everyday devices is consistent with that viewpoint. Additionally, it emphasizes how crucial observability, boundaries, and gradual development are to the applications I create.

Together, the artifacts tell a cohesive story of enhancing the same application from several angles. The software engineering work demonstrates my ability to update a codebase while maintaining consistency in behavior and enhancing safety and clarity. The algorithm's performance demonstrates my ability to select a structure that ensures the timing logic is scalable and predictable. My ability to develop a schema, write a migration that protects user data, and index for performance is demonstrated by my database work. Each artifact focuses on one dimension of the same product and they reinforce one another. The result is code that is clearer to read, more efficient to schedule, and more reliable to store and query. Together they demonstrate the range of skills that matter on a mobile team.

By completing the program, I learned how to tackle new problems in a repeatable manner. I start with a solid strategy that enhances the system by making the smallest change required to implement the enhancement, use focused tests to confirm the new behavior, and document my findings so that others can build upon them. That template has influenced my values and aspirations as a developer. I want to help create mobile applications that place value on trustworthy, straightforward user experiences by combining careful design, intelligent algorithms, reliable data models, and a security mindset.

# **Code Review**
[Code Review YouTube Link](https://www.youtube.com/watch?v=AVUiwthUgA0)

# **Software Design and Engineering Artifact** [Files Link](https://github.com/MRC1994/CS-499/tree/main/Software%20Design%20and%20Engineering)
The artifact is an Android event tracking app that enables users to create events and receive text reminders. In CS 499, I improved my Java-based CS 360 project by moving the codebase to Kotlin while preserving its original functionality. With its UI layer, Room persistence layer, and integration with platform services like AlarmManager and SMS, this artifact exemplifies a comprehensive yet targeted application, which is why I chose it. As I had intended for this milestone, that combination allowed me to show a modest security hardening of the broadcast path along with a realistic modernization effort.

Because it demonstrates the practical skills required for mobile teams, I included this artifact in my ePortfolio. Experience with Kotlin idioms, such as data classes for entities, explicit nullability of DAO return types, and effective collection and string operations, are all demonstrated by the migration. It also shows that I can change the app glue code without changing the behavior that is visible to the user. For example, Kotlin data classes have taken the place of Java objects for Event and PhoneNumber, and getEventById now returns a nullable type that needs to be verified by the recipient before use. By preventing the alarm receiver from exporting and adding a runtime permission check for SMS, I also decreased the broadcast surface. After adding the precise alarm permission for more recent Android versions at the platform level, I also confirmed that the app continues to schedule and manage reminders correctly. I was able to reduce boilerplate code and improve clarity without sacrificing the stability of the activities and the Room model. My Module One plan made specific reference to these improvements, such as the language migration and receiver hardening, and the outcomes achieve that goal.

In Module One, I achieved the results I had hoped for from this improvement. The code is simpler for another developer to read and edit thanks to the Kotlin rewrite. I created a concise design justification outlining the changes and their reasons for professional communication. I refactored the code to Kotlin while maintaining behavior using contemporary tools and techniques for software engineering and design. By making the SmsAlarmReceiver internal to the application and verifying permissions prior to sending messages, I was able to minimize exposure for security. These were the results I promised to cover for this category, and I will continue to add to in the coming assignments. As originally intended, my algorithm and database improvements will be covered in later work.

I learned a lot about writing safer and more efficient Android code by switching the project from Java to Kotlin. I got a baseline from the automatic converter, but the real effort was in making the output idiomatic. To make the compiler enforce checks that had previously been informal, I changed model classes to data classes, tightened nullability throughout, and substituted Kotlin properties for getters and setters. I had to add early returns in the receiver and switch to a safer pattern for obtaining the SmsManager after updating DAO signatures to return nullable types revealed a few places where the Java code had assumed objects would always be present. To make sure scheduling remained reliable on API 31 and later, I had to examine how alarms broadcast intents on more recent Android versions and add the precise alarm permission. Using explicit annotations and catching SecurityException around SMS sending, I resolved low-level Java and Kotlin differences between the Room and Android APIs, such as default values for function parameters and exception handling. Refactoring the code while preserving the app's functionality and ensuring that nullability changes did not result in errors was the primary challenge. These tradeoff changes improved the application's security and organization while strengthening processes I intend to use on a mobile development team, like encouraging compiler-verified contracts and lowering component exposure.

# **Algorithms and Data Structures Artifact** [Files Link](https://github.com/MRC1994/CS-499/tree/main/Algorithms%20and%20Data%20Structures)
The Android event tracking app that I used for category one is the same artifact I'm using for category two. It started out as my CS 360 project, which I improved upon in CS 499 with an emphasis on the data structures and algorithms that drive reminder scheduling. I created a scheduler for this milestone that arranges upcoming reminders in a priority structure and only keeps the next reminder loaded in the operating system. Through the use of a data structure that exhibits predictable behavior as the number of events increases, the timing logic was moved from scattered activity code to a single component.

This item was chosen for my ePortfolio because it shows that I can select and apply an appropriate data structure to a real feature while taking accuracy and performance into account. The primary improvement is a scheduler that uses a min-heap data structure to create a scheduler in place of the existing event alarms. The app now only sets the OS alarm for the earliest reminder stored in a heap keyed by trigger time. When it goes off, the app removes it from the heap, sends the SMS, determines the next reminder if one exists, puts it back into the heap, and sets the alarm for the newly determined reminder. This results in fewer wake-ups and reminders remaining on schedule.

I met the outcomes I planned to meet for this category. In Module One I stated that the algorithms and data structures enhancement would use a min heap to manage reminders and that goal is now satisfied in the running app. The update maintains the user visible behavior while improving the efficiency and predictability of the underlying logic. It aligns with the outcomes for designing and evaluating computing solutions with appropriate algorithmic principles and for communicating those choices in a clear way through the accompanying design narrative. I don't have any updates to my outcome-coverage plans.

Improving the artifact taught me how important it is to get the edges and structure just right for reliability. Testing behavior when a reminder time is already within the offset window, when an activity is paused while the user is still editing, and when the app is rebuilt from the database after returning to the list screen was the interesting work. Selecting the priority queue was simple. I added a basic idempotent send to prevent a single reminder from firing twice in a brief period of time, and I verified that the app should never schedule or send a reminder until the event is persisted. Additionally, I confirmed that past-due reminders are handled as one-time sends rather than being clamped to now on each rebuild. The purpose of applying the appropriate data structure to a user-facing feature is to make the behavior easy to understand and rationalize, and these minor adjustments achieved this goal. My practice of creating the plan first, carrying it out straight from it, and then using logs and quick tests to confirm the common path and the awkward edges the user will encounter was reinforced by the experience.

# **Databases Artifact** [Files Link](https://github.com/MRC1994/CS-499/tree/main/Databases)
The artifact is the Android event tracking app, which I initially developed in CS 360 and have since improved in CS 499. I concentrated on the persistence model that facilitates reminder scheduling for the databases category. I made an index on that column, added a stored trigger time in Coordinated Universal Time as an epoch millisecond value, and wrote a migration that fills the new field with the existing dateTime column while preserving stored rows.

I selected this item for my ePortfolio because it shows that I can safely edit the contents in a live database and consider how the database can affect and enable features. The schema change that added the remindAtUtc column, the migration that rebuilt the table according to Room expectations, the backfill from the current display string, and the index that enables quick queries on the next reminder are the components that best showcase my skills and abilities in creating and maintaining databases. Also, the scheduler can avoid time zone and daylight saving problems and avoid string parsing by using a single, clear epoch value and retains the original date string for editing and display. I checked the table information and index metadata and used the Database Inspector to confirm the outcome. Along with the planned modifications, I enhanced data security by switching to salted PBKDF2 hashes and removing the plain text password storage, which better aligns the application with responsible user credential handling. The database modifications follow the same pattern as the description of my previous improvements, which placed equal emphasis on useful enhancements that maintain user-visible behavior.

I met the outcomes that I aimed to cover for this category as laid out in the Module One assignment. The app now stores a precise trigger time, uses an index to support upcoming lookups, and includes a migration that keeps data intact through the upgrade. These changes improve the reliability and performance of scheduling without altering the user experience. The password hashing upgrade extends the security mindset I have applied throughout the project and complements the databases work by protecting stored data. I don't have any updates to my outcome-coverage plans.

By improving the databases in the app, I learned how to handle room migrations in a way that strikes a balance between accuracy and safety. Also, I discovered that, particularly when index names and default values can result in schema verification failures, it is frequently more dependable to recreate a table to match the precise schema that Room validates rather than attempting to change columns in place. I used straightforward queries to verify the migration, making sure the new column was present, the index name was correct, and the existing rows had nonzero epoch values. By first confirming a legacy password and then saving the secure hash for subsequent logins, I also learned how to implement a credential upgrade path that keeps users from being locked out. The main challenges were understanding why the first migration failed, aligning the new table with Room conventions, and keeping the changes minimal so the rest of the codebase did not need to be updated. The result is a cleaner persistence model that the scheduler can use directly, a safer approach to credential storage, and a clearer picture of how small database decisions affect user facing behavior.
